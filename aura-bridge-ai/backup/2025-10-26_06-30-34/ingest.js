const { S3Client, PutObjectCommand } = require('@aws-sdk/client-s3')
const { DynamoDBClient, PutItemCommand } = require('@aws-sdk/client-dynamodb')

const s3 = new S3Client({})
const ddb = new DynamoDBClient({})

module.exports.handler = async (event) => {
	// event from IoT contains .message
	const bucket = process.env.BUCKET_NAME
	const table = process.env.TABLE_NAME
	const expectedThing = process.env.THING_NAME
	let jobId = `job_${Date.now()}`

	let payload
	try {
		payload = typeof event === 'string' ? JSON.parse(event) : (event?.message ? JSON.parse(event.message) : event)
	} catch (e) {
		payload = { error: 'invalid', raw: String(event) }
	}

	// Relax client validation: just log mismatch, do not reject
	const clientId = event?.clientId || event?.clientid
	if (expectedThing && clientId && clientId !== expectedThing) {
		console.warn(`IoT clientId ${clientId} != expected THING_NAME ${expectedThing}; continuing.`)
	}

	// Map Jetson payload -> internal canonical format
	// Jetson sends: { robot_model, path_id, timestamp, fixtures, path_points: [{x,y,z}], grasp_events: [{index,event}] }
	let canonicalPath = []
	if (Array.isArray(payload?.path_points)) {
		// Convert mm (Jetson) -> meters for Three.js scene
		canonicalPath = payload.path_points.map((p) => ({ x: Number(p.x) / 1000, y: Number(p.y) / 1000, z: Number(p.z) / 1000 }))
		if (Array.isArray(payload?.grasp_events)) {
			payload.grasp_events.forEach((ge) => {
				const i = ge?.index
				if (Number.isInteger(i) && canonicalPath[i]) {
					if (ge.event === 'grasp') canonicalPath[i].grasp = true
					if (ge.event === 'release') canonicalPath[i].grasp = false
				}
			})
		}
	}

	const valid = Array.isArray(canonicalPath) && canonicalPath.length >= 2
	const status = valid ? 'VALID' : 'INVALID'

	// Basic motion code generation from path/grasp events
	const fmtPoint = (p, i) => `P[${i + 1}] = X ${p.x.toFixed(3)} Y ${p.y.toFixed(3)} Z ${p.z.toFixed(3)}`
	const karelBody = canonicalPath.map((p, i) => `  L ${fmtPoint(p, i)}  FINE`).join('\n')
	const karel = `PROGRAM AURA_BRIDGE_PATH\n  ! Auto-generated motion from Lambda\n${karelBody}\nEND\n`
	const krlBody = canonicalPath.map((p) => `  LIN {X ${p.x.toFixed(3)}, Y ${p.y.toFixed(3)}, Z ${p.z.toFixed(3)}} C_DIS`).join('\n')
	const krl = `DEF AURA_BRIDGE_PATH()\n  ; Auto-generated motion from Lambda\n${krlBody}\nEND\n`
	
	// ABB RAPID code generation
	const rapidTargets = canonicalPath.map((p, i) => `CONST robtarget p${i + 1} := [${p.x}, ${p.y}, ${p.z}, [1, 0, 0, 0], [0, 0, 0, 0], [9E+09, 9E+09, 9E+09, 9E+09, 9E+09, 9E+09]];`).join('\n')
	const rapidMotions = canonicalPath.map((p, i) => `    MoveL p${i + 1}, v500, fine, tool0;`).join('\n')
	const rapid = `MODULE AuraBridgeProgram\n! Generated by Aura Bridge AI\n\n${rapidTargets}\n\nPROC main()\n${rapidMotions}\nENDPROC\n\nENDMODULE`

	// Optionally call Bedrock to refine (guarded by env)
	let refinedKarel = null, refinedKrl = null, refinedRapid = null
	if (process.env.BEDROCK_ENABLED === 'true') {
		try {
			const { BedrockRuntimeClient, InvokeModelCommand } = require('@aws-sdk/client-bedrock-runtime')
			const br = new BedrockRuntimeClient({})
			const motionDefaults = {
				speed_mm_s: 200,
				termination: 'FINE',
				kuka_approx: 'C_DIS'
			}
			const pathJson = JSON.stringify({ points: canonicalPath, grasp_events: payload?.grasp_events || [], fixtures: payload?.fixtures || null }).slice(0, 15000)
			const system = [
				'You are a senior ABB robotics engineer with 15+ years experience in Robot Studio programming.',
				'Generate industry-grade, production-ready ABB RAPID programs that compile perfectly in Robot Studio.',
				'Follow ABB RAPID syntax exactly. Include proper safety, error handling, and Robot Studio compatibility.',
				'Output must be plug-and-play ready for immediate use in manufacturing environments.'
			].join(' ')
			const prompt = [
				'INPUT:',
				`- Waypoints (meters) and events JSON: ${pathJson}`,
				`- Defaults: speed=${motionDefaults.speed_mm_s} mm/sec, termination=${motionDefaults.termination}, kuka_approx=${motionDefaults.kuka_approx}`,
				'',
				'ABB RAPID PROGRAM REQUIREMENTS (Robot Studio Compatible):',
				'1. MODULE STRUCTURE:',
				'   - Start with: MODULE AuraBridgeProgram',
				'   - Include comprehensive comments',
				'   - End with: ENDMODULE',
				'',
				'2. ROBTARGET DEFINITIONS:',
				'   - Define all points as CONST robtarget declarations',
				'   - Use proper format: CONST robtarget p1 := [x, y, z, [1,0,0,0], [0,0,0,0], [9E+09,9E+09,9E+09,9E+09,9E+09,9E+09]];',
				'   - Include proper orientation quaternions',
				'   - Add configuration data for robot positioning',
				'',
				'3. MOTION INSTRUCTIONS:',
				'   - Use MoveL for linear movements: MoveL p1, v500, fine, tool0;',
				'   - Use MoveJ for joint movements: MoveJ p1, v1000, fine, tool0;',
				'   - Include proper speed data (v1000, v500, v200)',
				'   - Use appropriate zone data (fine, z10, z20)',
				'   - Reference tool0 and wobj0',
				'',
				'4. SPEED AND ZONE DATA:',
				'   - Define speeddata: CONST speeddata v500 := [500, 200, 2000, 500];',
				'   - Define zonedata: CONST zonedata z10 := [10, 10, 10, 10, 10, 10];',
				'   - Use appropriate speed profiles for different operations',
				'',
				'5. SAFETY FEATURES:',
				'   - Include home position movements',
				'   - Add error handling procedures',
				'   - Include proper initialization sequences',
				'   - Add emergency stop capabilities',
				'',
				'6. GRIPPER CONTROL:',
				'   - Use digital outputs: Set do1; / Reset do1;',
				'   - Add comments: ! GRASP or ! RELEASE',
				'   - Include safety delays: WaitTime 0.5;',
				'',
				'7. ROBOT STUDIO COMPATIBILITY:',
				'   - Use standard ABB RAPID syntax only',
				'   - No custom functions or variables',
				'   - Proper indentation and formatting',
				'   - Include all required declarations',
				'',
				'FORMAT (must match exactly):',
				'```RAPID',
				'<COMPLETE_ABB_RAPID_PROGRAM_HERE>',
				'```',
				'```KRL',
				'<COMPLETE_KUKA_KRL_PROGRAM_HERE>',
				'```'
			].join('\n')
			const model = process.env.BEDROCK_MODEL || 'anthropic.claude-3-haiku-20240307-v1:0'
			const body = JSON.stringify({
				anthropic_version: 'bedrock-2023-05-31',
				max_tokens: 4000,
				temperature: 0,
				messages: [
					{ role: 'user', content: [{ type: 'text', text: prompt }] }
				],
				system
			})
			const resp = await br.send(new InvokeModelCommand({ modelId: model, contentType: 'application/json', accept: 'application/json', body }))
			const txt = JSON.parse(new TextDecoder('utf-8').decode(resp.body)).content?.[0]?.text || ''
			// Extract fenced code blocks
			const rapidBlock = /```RAPID\n([\s\S]*?)```/i.exec(txt)
			const krlBlock = /```KRL\n([\s\S]*?)```/i.exec(txt)
			refinedRapid = rapidBlock ? rapidBlock[1].trim() : null
			refinedKrl = krlBlock ? krlBlock[1].trim() : null
		} catch (e) {
			console.warn('Bedrock refinement failed:', e?.message || e)
		}
	}

	// Store artifacts
	// Store original payload and normalized path for API
	await s3.send(new PutObjectCommand({ Bucket: bucket, Key: `${jobId}/iot_raw.json`, Body: JSON.stringify(payload) }))
	await s3.send(new PutObjectCommand({ Bucket: bucket, Key: `${jobId}/path.json`, Body: JSON.stringify({ points: canonicalPath, fixtures: payload?.fixtures || null, grasp_events: payload?.grasp_events || [] }) }))
	await s3.send(new PutObjectCommand({ Bucket: bucket, Key: `${jobId}/karel.LS`, Body: karel }))
	await s3.send(new PutObjectCommand({ Bucket: bucket, Key: `${jobId}/kuka.src`, Body: krl }))
	await s3.send(new PutObjectCommand({ Bucket: bucket, Key: `${jobId}/abb.mod`, Body: rapid }))
	if (refinedKarel) await s3.send(new PutObjectCommand({ Bucket: bucket, Key: `${jobId}/karel.refined.LS`, Body: refinedKarel }))
	if (refinedKrl) await s3.send(new PutObjectCommand({ Bucket: bucket, Key: `${jobId}/kuka.refined.src`, Body: refinedKrl }))
	if (refinedRapid) await s3.send(new PutObjectCommand({ Bucket: bucket, Key: `${jobId}/abb.refined.mod`, Body: refinedRapid }))

	await ddb.send(new PutItemCommand({
		TableName: table,
		Item: {
			jobId: { S: jobId },
			status: { S: status },
			pathKey: { S: `${jobId}/path.json` },
			karelKey: { S: `${jobId}/karel.LS` },
			krlKey: { S: `${jobId}/kuka.src` },
			rapidKey: { S: `${jobId}/abb.mod` },
			refinedKarelKey: { S: refinedKarel ? `${jobId}/karel.refined.LS` : '' },
			refinedKrlKey: { S: refinedKrl ? `${jobId}/kuka.refined.src` : '' },
			refinedRapidKey: { S: refinedRapid ? `${jobId}/abb.refined.mod` : '' },
			updatedAt: { S: new Date().toISOString() }
		}
	}))

	return { ok: true, jobId, status }
}
