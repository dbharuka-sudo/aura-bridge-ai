// ABB RAPID Code Generator for Aura Bridge AI
// Generates industry-standard ABB RAPID programs for Robot Studio

const ABBRapidGenerator = {
  // Generate ABB RAPID program from gesture data
  generateRapidProgram: (gestureData, programName = 'AuraBridgeProgram') => {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
    
    // Clean program name (ABB RAPID naming conventions)
    const cleanName = programName.replace(/[^a-zA-Z0-9_]/g, '').substring(0, 20)
    
    let rapidCode = `MODULE ${cleanName}
! Generated by Aura Bridge AI
! Timestamp: ${timestamp}
! Program for ABB Robot Studio

! Data declarations
CONST robtarget pHome := [${gestureData[0]?.x || 0}, ${gestureData[0]?.y || 0}, ${gestureData[0]?.z || 0}, [1, 0, 0, 0], [0, 0, 0, 0], [9E+09, 9E+09, 9E+09, 9E+09, 9E+09, 9E+09]];

`

    // Generate robtarget declarations for each waypoint
    gestureData.forEach((point, index) => {
      const targetName = `p${index + 1}`
      rapidCode += `CONST robtarget ${targetName} := [${point.x}, ${point.y}, ${point.z}, [1, 0, 0, 0], [0, 0, 0, 0], [9E+09, 9E+09, 9E+09, 9E+09, 9E+09, 9E+09]];
`
    })

    // Generate main procedure
    rapidCode += `
PROC main()
    ! Move to home position
    MoveJ pHome, v1000, fine, tool0;
    
    ! Execute gesture path
`

    // Generate motion instructions
    gestureData.forEach((point, index) => {
      const targetName = `p${index + 1}`
      const speed = index === 0 ? 'v1000' : 'v500' // Slower speed for precision
      const zone = index === gestureData.length - 1 ? 'fine' : 'z10' // Fine positioning for last point
      
      rapidCode += `    MoveL ${targetName}, ${speed}, ${zone}, tool0;
`
    })

    // Add return to home
    rapidCode += `
    ! Return to home position
    MoveJ pHome, v1000, fine, tool0;
    
ENDPROC

ENDMODULE`

    return rapidCode
  },

  // Generate ABB RAPID with advanced features
  generateAdvancedRapidProgram: (gestureData, programName = 'AuraBridgeAdvanced') => {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
    const cleanName = programName.replace(/[^a-zA-Z0-9_]/g, '').substring(0, 20)
    
    let rapidCode = `MODULE ${cleanName}
! Advanced ABB RAPID Program
! Generated by Aura Bridge AI
! Timestamp: ${timestamp}

! Data declarations
CONST robtarget pHome := [${gestureData[0]?.x || 0}, ${gestureData[0]?.y || 0}, ${gestureData[0]?.z || 0}, [1, 0, 0, 0], [0, 0, 0, 0], [9E+09, 9E+09, 9E+09, 9E+09, 9E+09, 9E+09]];

! Speed and zone data
CONST speeddata vFast := [1000, 500, 5000, 1000];
CONST speeddata vSlow := [200, 100, 1000, 200];
CONST zonedata zFine := fine;
CONST zonedata zApproach := [20, 20, 20, 20, 20, 20];

! Tool and work object declarations
CONST tooldata tool0 := [TRUE, [[0, 0, 0], [1, 0, 0, 0]], [1, [0, 0, 0], [1, 0, 0, 0], 0, 0, 0]];
CONST wobjdata wobj0 := [FALSE, TRUE, "", [[0, 0, 0], [1, 0, 0, 0]], [[0, 0, 0], [1, 0, 0, 0]]];

`

    // Generate robtarget declarations
    gestureData.forEach((point, index) => {
      const targetName = `p${index + 1}`
      rapidCode += `CONST robtarget ${targetName} := [${point.x}, ${point.y}, ${point.z}, [1, 0, 0, 0], [0, 0, 0, 0], [9E+09, 9E+09, 9E+09, 9E+09, 9E+09, 9E+09]];
`
    })

    // Generate main procedure with error handling
    rapidCode += `
PROC main()
    ! Initialize robot
    Reset do1;
    Set do1;
    
    ! Move to home position
    MoveJ pHome, vFast, zFine, tool0, wobj0;
    
    ! Execute gesture sequence
`

    // Generate motion instructions with varying speeds
    gestureData.forEach((point, index) => {
      const targetName = `p${index + 1}`
      const speed = index % 3 === 0 ? 'vFast' : 'vSlow'
      const zone = index === gestureData.length - 1 ? 'zFine' : 'zApproach'
      
      rapidCode += `    MoveL ${targetName}, ${speed}, ${zone}, tool0, wobj0;
`
    })

    // Add completion sequence
    rapidCode += `
    ! Complete gesture sequence
    Reset do1;
    
    ! Return to home position
    MoveJ pHome, vFast, zFine, tool0, wobj0;
    
ENDPROC

! Error handling procedure
PROC errorHandler()
    ! Emergency stop and return to safe position
    Stop;
    MoveJ pHome, vSlow, zFine, tool0, wobj0;
ENDPROC

ENDMODULE`

    return rapidCode
  },

  // Generate ABB RAPID with path optimization
  generateOptimizedRapidProgram: (gestureData, programName = 'AuraBridgeOptimized') => {
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-')
    const cleanName = programName.replace(/[^a-zA-Z0-9_]/g, '').substring(0, 20)
    
    // Optimize path by removing redundant points
    const optimizedPath = ABBRapidGenerator.optimizePath(gestureData)
    
    let rapidCode = `MODULE ${cleanName}
! Optimized ABB RAPID Program
! Generated by Aura Bridge AI
! Timestamp: ${timestamp}
! Optimized path with ${optimizedPath.length} waypoints

! Data declarations
CONST robtarget pHome := [${optimizedPath[0]?.x || 0}, ${optimizedPath[0]?.y || 0}, ${optimizedPath[0]?.z || 0}, [1, 0, 0, 0], [0, 0, 0, 0], [9E+09, 9E+09, 9E+09, 9E+09, 9E+09, 9E+09]];

! Speed profiles for different path segments
CONST speeddata vApproach := [500, 200, 2000, 500];
CONST speeddata vExecute := [300, 150, 1500, 300];
CONST speeddata vRetract := [800, 400, 4000, 800];

! Zone data for smooth motion
CONST zonedata zApproach := [30, 30, 30, 30, 30, 30];
CONST zonedata zExecute := [10, 10, 10, 10, 10, 10];
CONST zonedata zRetract := [50, 50, 50, 50, 50, 50];

`

    // Generate optimized robtarget declarations
    optimizedPath.forEach((point, index) => {
      const targetName = `p${index + 1}`
      rapidCode += `CONST robtarget ${targetName} := [${point.x}, ${point.y}, ${point.z}, [1, 0, 0, 0], [0, 0, 0, 0], [9E+09, 9E+09, 9E+09, 9E+09, 9E+09, 9E+09]];
`
    })

    // Generate optimized motion sequence
    rapidCode += `
PROC main()
    ! Approach phase
    MoveJ p1, vApproach, zApproach, tool0;
    
    ! Execute optimized path
`

    optimizedPath.forEach((point, index) => {
      const targetName = `p${index + 1}`
      const speed = index === 0 ? 'vApproach' : (index === optimizedPath.length - 1 ? 'vRetract' : 'vExecute')
      const zone = index === 0 ? 'zApproach' : (index === optimizedPath.length - 1 ? 'zRetract' : 'zExecute')
      
      rapidCode += `    MoveL ${targetName}, ${speed}, ${zone}, tool0;
`
    })

    rapidCode += `
    ! Return to home
    MoveJ pHome, vRetract, zRetract, tool0;
    
ENDPROC

ENDMODULE`

    return rapidCode
  },

  // Path optimization algorithm
  optimizePath: (path) => {
    if (path.length <= 2) return path
    
    const optimized = [path[0]] // Always keep first point
    const threshold = 0.01 // Minimum distance threshold (10mm)
    
    for (let i = 1; i < path.length - 1; i++) {
      const prev = path[i - 1]
      const curr = path[i]
      const next = path[i + 1]
      
      // Calculate distance from previous point
      const dist = Math.sqrt(
        Math.pow(curr.x - prev.x, 2) + 
        Math.pow(curr.y - prev.y, 2) + 
        Math.pow(curr.z - prev.z, 2)
      )
      
      // Keep point if distance is significant
      if (dist > threshold) {
        optimized.push(curr)
      }
    }
    
    optimized.push(path[path.length - 1]) // Always keep last point
    return optimized
  }
}

// Export for use in other modules
if (typeof module !== 'undefined' && module.exports) {
  module.exports = ABBRapidGenerator
}

// Test the generator
console.log('ü§ñ ABB RAPID Generator Ready!')
console.log('‚úÖ Features:')
console.log('  - Standard RAPID program generation')
console.log('  - Advanced RAPID with error handling')
console.log('  - Optimized path generation')
console.log('  - ABB Robot Studio compatibility')
console.log('  - Industry-standard syntax')
console.log('  - Proper file format (.mod files)')

// Example usage
const sampleGestureData = [
  { x: -0.210, y: -0.083, z: -1.121 },
  { x: -0.201, y: -0.051, z: -1.079 },
  { x: -0.280, y: -0.030, z: -1.118 },
  { x: -0.317, y: -0.093, z: -1.112 },
  { x: -0.284, y: -0.142, z: -1.052 }
]

console.log('üìù Sample RAPID Program Generated:')
const sampleProgram = ABBRapidGenerator.generateRapidProgram(sampleGestureData, 'GestureDemo')
console.log(sampleProgram.substring(0, 200) + '...')


